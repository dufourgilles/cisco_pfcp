*** ../epan/dissectors/packet-pfcp.original	Mon May 20 13:14:48 2019
--- ../epan/dissectors/packet-pfcp.c	Tue May 21 19:49:45 2019
***************
*** 13,19 ****
   * Ref 3GPP TS 29.244 V15.3.0 (2018-09-23)
   */
  #include "config.h"
! 
  #include <epan/packet.h>
  #include <epan/conversation.h>
  #include <epan/etypes.h>
--- 13,19 ----
   * Ref 3GPP TS 29.244 V15.3.0 (2018-09-23)
   */
  #include "config.h"
! #include <stdio.h>
  #include <epan/packet.h>
  #include <epan/conversation.h>
  #include <epan/etypes.h>
*************** static int hf_pfcp_averaging_window = -1
*** 511,516 ****
--- 511,577 ----
  
  static int hf_pfcp_paging_policy_indicator = -1;
  
+ 
+ // Cisco
+ 
+ static int hf_pfcp_cisco_config_action = -1;
+ static int hf_pfcp_cisco_correlation_id = -1;
+ static int hf_pfcp_cisco_sub_part_number = -1;
+ static int hf_pfcp_cisco_sub_part_index = -1;
+ static int hf_pfcp_cisco_tlv_content = -1;
+ static int hf_pfcp_cisco_rbase_name = -1;
+ static int hf_pfcp_cisco_bitoctet = -1;
+ static int hf_pfcp_cisco_msisdn_len = -1;
+ static int hf_pfcp_cisco_msisdn_val = -1;
+ static int hf_pfcp_cisco_imsi_len = -1;
+ static int hf_pfcp_cisco_imsi_val = -1;
+ static int hf_pfcp_cisco_entity_type = -1;
+ static int hf_pfcp_cisco_query_type = -1;
+ static int hf_pfcp_cisco_spare = -1;
+ static int hf_pfcp_cisco_entity_name_len = -1;
+ static int hf_pfcp_cisco_entity_name_val = -1;
+ static int hf_pfcp_cisco_classifier_type = -1;
+ static int hf_pfcp_cisco_classifier_len = -1;
+ static int hf_pfcp_cisco_classifier_val = -1;
+ static int hf_pfcp_cisco_response_entity_type = -1;
+ static int hf_pfcp_cisco_response_part_number = -1;
+ static int hf_pfcp_cisco_response_total_part_number = -1;
+ static int hf_pfcp_cisco_response_data = -1;
+ static int hf_pfcp_cisco_response_type = -1;
+ static int hf_pfcp_cisco_response_missing_parts = -1;
+ static int hf_pfcp_cisco_packet_measurement_spare = -1;
+ static int hf_pfcp_cisco_packet_measurement_total = -1;
+ static int hf_pfcp_cisco_packet_measurement_uplink = -1;
+ static int hf_pfcp_cisco_packet_measurement_downlink = -1;
+ static int hf_pfcp_cisco_imei_len = -1;
+ static int hf_pfcp_cisco_imei_val = -1;
+ static int hf_pfcp_cisco_callid = -1;
+ static int hf_pfcp_cisco_intercept_id = -1;
+ static int hf_pfcp_cisco_charging_id = -1;
+ static int hf_pfcp_cisco_bearer_id = -1;
+ static int hf_pfcp_cisco_context_name_len = -1;
+ static int hf_pfcp_cisco_context_name_val = -1;
+ static int hf_pfcp_cisco_node_capability_max_session = -1;
+ static int hf_pfcp_cisco_charging_chars = -1;
+ static int hf_pfcp_cisco_gtpp_group_name_len = -1;
+ static int hf_pfcp_cisco_gtpp_group_name_val = -1;
+ static int hf_pfcp_cisco_gtpp_context_id = -1;
+ static int hf_pfcp_cisco_policy_name_len = -1;
+ static int hf_pfcp_cisco_policy_name = -1;
+ static int hf_pfcp_cisco_policy_type = -1;
+ static int hf_pfcp_cisco_diameter_interim_interval = -1;
+ static int hf_pfcp_cisco_aaa_group_name_len = -1;
+ static int hf_pfcp_cisco_aaa_group_name_val = -1;
+ static int hf_pfcp_cisco_aaa_group_context_id = -1;
+ static int hf_pfcp_cisco_radius_interim_interval = -1;
+ static int hf_pfcp_cisco_gy_offline_charging = -1;
+ static int hf_pfcp_cisco_gtpp_dictionnary = -1;
+ static int hf_pfcp_cisco_gy_offline_charging_status = -1;
+ static int hf_pfcp_cisco_traffic_class = -1;
+ static int hf_pfcp_cisco_copy_inner_outer_flag = -1;
+ 
+ // end cisco
+ 
  static int ett_pfcp = -1;
  static int ett_pfcp_flags = -1;
  static int ett_pfcp_ie = -1;
*************** static void dissect_pfcp_ethernet_packet
*** 646,651 ****
--- 707,737 ----
  static void dissect_pfcp_ethernet_traffic_information(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, proto_item *item, guint16 length, guint8 message_type, pfcp_session_args_t *args _U_);
  static void dissect_pfcp_additional_monitoring_time(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, proto_item *item, guint16 length, guint8 message_type, pfcp_session_args_t *args _U_);
  
+ // Cisco
+ static void dissect_pfcp_cisco_update_addtl_forward_params(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, proto_item *item, guint16 length, guint8 message_type, pfcp_session_args_t *args);
+ static void dissect_pfcp_cisco_stats_request(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, proto_item *item, guint16 length, guint8 message_type, pfcp_session_args_t *args);
+ static void dissect_pfcp_cisco_config_action(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, proto_item *item, guint16 length, guint8 message_type, pfcp_session_args_t *args);
+ static void dissect_pfcp_cisco_correlation_id(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, proto_item *item, guint16 length, guint8 message_type, pfcp_session_args_t *args);
+ static void dissect_pfcp_cisco_sub_part_number(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, proto_item *item, guint16 length, guint8 message_type, pfcp_session_args_t *args);
+ static void dissect_pfcp_cisco_sub_part_index(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, proto_item *item, guint16 length, guint8 message_type, pfcp_session_args_t *args);
+ static void dissect_pfcp_cisco_content_tlv(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, proto_item *item, guint16 length, guint8 message_type, pfcp_session_args_t *args);
+ static void dissect_pfcp_cisco_rbase_name(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, proto_item *item, guint16 length, guint8 message_type, pfcp_session_args_t *args);
+ static void dissect_pfcp_cisco_nsh_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, proto_item *item, guint16 length, guint8 message_type, pfcp_session_args_t *args);
+ static void dissect_pfcp_cisco_query_params(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, proto_item *item, guint16 length, guint8 message_type, pfcp_session_args_t *args);
+ static void dissect_pfcp_cisco_classifier_params(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, proto_item *item, guint16 length, guint8 message_type, pfcp_session_args_t *args);
+ static void dissect_pfcp_cisco_stats_response(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, proto_item *item, guint16 length, guint8 message_type, pfcp_session_args_t *args);
+ static void dissect_pfcp_cisco_response_ack(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, proto_item *item, guint16 length, guint8 message_type, pfcp_session_args_t *args);
+ static void dissect_pfcp_cisco_packet_measurement(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, proto_item *item, guint16 length, guint8 message_type, pfcp_session_args_t *args);
+ static void dissect_pfcp_cisco_extended_measurement(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, proto_item *item, guint16 length, guint8 message_type, pfcp_session_args_t *args);
+ static void dissect_pfcp_cisco_recalculate_measurement(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, proto_item *item, guint16 length, guint8 message_type, pfcp_session_args_t *args);
+ static void dissect_pfcp_cisco_sub_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, proto_item *item, guint16 length, guint8 message_type, pfcp_session_args_t *args);
+ static void dissect_pfcp_cisco_intr_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, proto_item *item, guint16 length, guint8 message_type, pfcp_session_args_t *args);
+ static void dissect_pfcp_cisco_node_capability(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, proto_item *item, guint16 length, guint8 message_type, pfcp_session_args_t *args);
+ static void dissect_pfcp_cisco_charging_params(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, proto_item *item, guint16 length, guint8 message_type, pfcp_session_args_t *args);
+ static void dissect_pfcp_cisco_gy_offline_charge(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, proto_item *item, guint16 length, guint8 message_type, pfcp_session_args_t *args);
+ static void dissect_pfcp_cisco_inner_packet_marking(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, proto_item *item, guint16 length, guint8 message_type, pfcp_session_args_t *args);
+ static void dissect_pfcp_cisco_transport_level_marking(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, proto_item *item, guint16 length, guint8 message_type, pfcp_session_args_t *args);
+ 
  static const true_false_string pfcp_id_predef_dynamic_tfs = {
      "Predefined by UP",
      "Dynamic by CP",
*************** static value_string_ext pfcp_message_typ
*** 760,765 ****
--- 846,879 ----
  #define PFCP_IE_EVENT_INFORMATION                148
  #define PFCP_IE_EVENT_REPORTING                  149
  
+ 
+ #define PFCP_IE_CISCO_UPDATE_ADDNL_FORW_PARAMS   201
+ #define PFCP_IE_CISCO_CONFIG_ACTION              202
+ #define PFCP_IE_CISCO_CORRELATION_ID             203
+ #define PFCP_IE_CISCO_SUB_PART_NUMBER            204
+ #define PFCP_IE_CISCO_SUB_PART_INDEX             205
+ #define PFCP_IE_CISCO_CONTENT_TLV                206
+ #define PFCP_IE_CISCO_RBASE_NAME                 207
+ #define PFCP_IE_CISCO_NSH_INFO                   208
+ #define PFCP_IE_CISCO_STATS_REQ                  209
+ #define PFCP_IE_CISCO_QUERY_PARAMS               210
+ #define PFCP_IE_CISCO_CLASSIFIER_PARAMS          211
+ #define PFCP_IE_CISCO_STATS_RES                  212
+ #define PFCP_IE_CISCO_STATS_RES_ACK              213
+ #define PFCP_IE_CISCO_PACKET_MEASUREMENT         214
+ #define PFCP_IE_CISCO_EXTENDED_MEASUREMENT_METHOD 215
+ #define PFCP_IE_CISCO_RECALCULATE_MEASUREMENT    216
+ #define PFCP_IE_CISCO_SUB_INFO                   217
+ #define PFCP_IE_CISCO_INTR_INFO                  218
+ #define PFCP_IE_CISCO_NODE_CAPABILITY            219
+ // 220 - 222 not used 
+ #define PFCP_IE_CISCO_CHARGING_PARAMS            223
+ #define PFCP_IE_CISCO_GY_OFFLINE_CHARGE          224
+ // 225 - 254 not used
+ #define PFCP_IE_CISCO_INNER_PACKET_MARKING       255
+ // 256 - 265 not used
+ #define PFCP_IE_CISCO_TRANSPORT_LEVEL_MARKING_OPTIONS 266
+ 
  static const value_string pfcp_ie_type[] = {
  
      { 0, "Reserved"},
*************** static const value_string pfcp_ie_type[]
*** 922,933 ****
--- 1036,1119 ----
      { 157, "Averaging Window"},                                     /* Extendable / Subclause 8.2.115 */
      { 158, "Paging Policy Indicator"},                              /* Extendable / Subclause 8.2.116 */
      //159 to 32767 Spare. For future use.
+     // cisco
+     { 201, "Cisco Update Additional Forwarding"},
+     { 202, "Cisco Config Action"},
+     { 203, "Cisco Correlation ID"},
+     { 204, "Cisco Sub Part Number"},
+     { 205, "Cisco Sub Part Index"},
+     { 206, "Cisco Content TLV"},
+     { 207, "Cisco RuleBase Name"},
+     { 208, "Cisco NSH-Info"},
+     { 209, "Cisco Stats Request"},
+     { 210, "Cisco Query Params"},
+     { 211, "Cisco Classiier Params"},
+     { 212, "Cisco Stats Response"},
+     { 213, "Cisco Response ACK/NACK"},
+     { 214, "Cisco Packet Measurement"},
+     { 215, "Cisco Extended Measurement"},
+     { 216, "Cisco Recalculate Measurement"},
+     { 217, "Cisco Sub Info"},
+     { 218, "Cisco Intr Info"},
+     { 219, "Cisco Node Capability"},
+     { 220, "Unknwon IE"},
+     { 221, "Unknwon IE"},
+     { 222, "Unknwon IE"},
+     { 223, "Cisco Charging Params"},
+     { 224, "Cisco Gy Offline Charge"},
+     { 225, "Unknwon IE"},
+     { 226, "Unknwon IE"},
+     { 227, "Unknwon IE"},
+     { 228, "Unknwon IE"},
+     { 229, "Unknwon IE"},
+     { 230, "Unknwon IE"},
+     { 231, "Unknwon IE"},
+     { 232, "Unknwon IE"},
+     { 233, "Unknwon IE"},
+     { 234, "Unknwon IE"},
+     { 235, "Unknwon IE"},
+     { 236, "Unknwon IE"},
+     { 237, "Unknwon IE"},
+     { 238, "Unknwon IE"},
+     { 239, "Unknwon IE"},
+     { 240, "Unknwon IE"},
+     { 241, "Unknwon IE"},
+     { 242, "Unknwon IE"},
+     { 243, "Unknwon IE"},
+     { 244, "Unknwon IE"},
+     { 245, "Unknwon IE"},
+     { 246, "Unknwon IE"},
+     { 247, "Unknwon IE"},
+     { 248, "Unknwon IE"},
+     { 249, "Unknwon IE"}, 
+     { 250, "Unknwon IE"},
+     { 251, "Unknwon IE"},
+     { 252, "Unknwon IE"},
+     { 253, "Unknwon IE"},
+     { 254, "Unknwon IE"},
+     { 255, "Cisco Inner Packet Marking"},
+     { 256, "Unknwon IE"},
+     { 257, "Unknwon IE"},
+     { 258, "Unknwon IE"},
+     { 259, "Unknwon IE"},
+     { 260, "Unknwon IE"},
+     { 261, "Unknwon IE"},
+     { 262, "Unknwon IE"},
+     { 263, "Unknwon IE"},
+     { 264, "Unknwon IE"},
+     { 265, "Unknwon IE"},
+     { 266, "Cisco Transport Lvl Marking"},
      //32768 to 65535 Vendor-specific IEs.
      {0, NULL}
  };
  
  static value_string_ext pfcp_ie_type_ext = VALUE_STRING_EXT_INIT(pfcp_ie_type);
  
+ static const value_string response_ack_nack[] = {
+     { 0, "Success"},
+     { 1, "Failure"}
+ };
+ 
  /* PFCP Session funcs*/
  static guint32
  pfcp_get_frame(address ip, guint64 seid, guint32 *frame) {
*************** dissect_pfcp_outer_header_creation(tvbuf
*** 3407,3413 ****
      * r to (r+1)   Port Number
      * The Port Number field shall be present if the Outer Header Creation Description requests the creation of a UDP/IP header
      */
!     if ((value & 0x0400) || (value & 0x0800)) {
          proto_tree_add_item(tree, hf_pfcp_outer_hdr_creation_port, tvb, offset, 2, ENC_BIG_ENDIAN);
          offset += 2;
      }
--- 3593,3599 ----
      * r to (r+1)   Port Number
      * The Port Number field shall be present if the Outer Header Creation Description requests the creation of a UDP/IP header
      */
!     if ((value & 0x0100) || (value & 0x0400) || (value & 0x0800)) {
          proto_tree_add_item(tree, hf_pfcp_outer_hdr_creation_port, tvb, offset, 2, ENC_BIG_ENDIAN);
          offset += 2;
      }
*************** dissect_pfcp_deact_predef_rules(tvbuff_t
*** 3970,3978 ****
   * 8.2.74   FAR ID
   */
  static int
! decode_pfcp_far_id(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, proto_item *item _U_, gint offset)
  {
!     guint32 far_id;
      guint8 far_id_flag;
      /* Octet 5 to 8 FAR ID value
       * The bit 8 of octet 5 is used to indicate if the Rule ID is dynamically allocated
--- 4156,4164 ----
   * 8.2.74   FAR ID
   */
  static int
! decode_pfcp_far_id(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, proto_item *item _U_, gint offset, guint16 length)
  {
!     guint32 far_id, mask = 0x7fffffff;
      guint8 far_id_flag;
      /* Octet 5 to 8 FAR ID value
       * The bit 8 of octet 5 is used to indicate if the Rule ID is dynamically allocated
*************** decode_pfcp_far_id(tvbuff_t *tvb, packet
*** 3982,3994 ****
       */
      far_id_flag = tvb_get_guint8(tvb,offset) & 0x80;
  
!     proto_tree_add_item(tree, hf_pfcp_far_id_flg, tvb, offset, 4, ENC_BIG_ENDIAN);
!     proto_tree_add_item_ret_uint(tree, hf_pfcp_far_id, tvb, offset, 4, ENC_BIG_ENDIAN, &far_id);
!     offset += 4;
! 
      proto_item_append_text(item, "%s %u",
          ((far_id_flag)? pfcp_id_predef_dynamic_tfs.true_string : pfcp_id_predef_dynamic_tfs.false_string),
!         (far_id & 0x7fffffff));
  
      return offset;
  }
--- 4168,4182 ----
       */
      far_id_flag = tvb_get_guint8(tvb,offset) & 0x80;
  
!     proto_tree_add_item(tree, hf_pfcp_far_id_flg, tvb, offset, 1, ENC_BIG_ENDIAN);
!     proto_tree_add_item_ret_uint(tree, hf_pfcp_far_id, tvb, offset, length, ENC_BIG_ENDIAN, &far_id);
!     offset += length;
!     if (length < 4) {
!         mask = mask >> (8 *(4 - length));
!     }
      proto_item_append_text(item, "%s %u",
          ((far_id_flag)? pfcp_id_predef_dynamic_tfs.true_string : pfcp_id_predef_dynamic_tfs.false_string),
!         (far_id & mask));
  
      return offset;
  }
*************** dissect_pfcp_far_id(tvbuff_t *tvb, packe
*** 3998,4004 ****
  {
      int offset = 0;
  
!     offset = decode_pfcp_far_id(tvb, pinfo, tree, item, offset);
  
      if (offset < length) {
          proto_tree_add_expert(tree, pinfo, &ei_pfcp_ie_data_not_decoded, tvb, offset, -1);
--- 4186,4192 ----
  {
      int offset = 0;
  
!     offset = decode_pfcp_far_id(tvb, pinfo, tree, item, offset, length);
  
      if (offset < length) {
          proto_tree_add_expert(tree, pinfo, &ei_pfcp_ie_data_not_decoded, tvb, offset, -1);
*************** dissect_pfcp_failed_rule_id(tvbuff_t *tv
*** 4203,4209 ****
              break;
          case 1:
              /* FAR ID */
!             offset = decode_pfcp_far_id(tvb, pinfo, tree, item, offset);
              break;
          case 2:
              /* QER ID */
--- 4391,4397 ----
              break;
          case 1:
              /* FAR ID */
!             offset = decode_pfcp_far_id(tvb, pinfo, tree, item, offset, length);
              break;
          case 2:
              /* QER ID */
*************** static const pfcp_ie_t pfcp_ies[] = {
*** 5346,5354 ****
--- 5534,5619 ----
      { NULL },                                                        /* End of List */
  };
  
+ 
+ static const pfcp_ie_t pfcp_cisco_ies[] = {
+ /*      201 */    { dissect_pfcp_cisco_update_addtl_forward_params },           /* PFCP_IE_UPDATE_ADDNL_FORW_PARAMS */
+ /*      202 */    { dissect_pfcp_cisco_config_action },                         /* PFCP_IE_CONFIG_ACTION */
+ /*      203 */    { dissect_pfcp_cisco_correlation_id },                        /* PFCP_IE_CORRELATION_ID */
+ /*      204 */    { dissect_pfcp_cisco_sub_part_number },                       /* PFCP_IE_SUB_PART_NUMBER */
+ /*      205 */    { dissect_pfcp_cisco_sub_part_index },                        /* PFCP_IE_SUB_PART_INDEX */
+ /*      206 */    { dissect_pfcp_cisco_content_tlv },                           /* PFCP_IE_CONTENT_TLV */
+ /*      207 */    { dissect_pfcp_cisco_rbase_name },                            /* PFCP_IE_RBASE_NAME */
+ /*      208 */    { dissect_pfcp_cisco_nsh_info },                              /* NSH-INFO */
+ /*      209 */    { dissect_pfcp_cisco_stats_request },                         /* Stats request IE */
+ /*      210 */    { dissect_pfcp_cisco_query_params },                          /* Query Params IE */
+ /*      211 */    { dissect_pfcp_cisco_classifier_params },                     /* Classifier Params IE */
+ /*      212 */    { dissect_pfcp_cisco_stats_response },                        /* Stats response IE */
+ /*      213 */    { dissect_pfcp_cisco_response_ack },                          /* Stats response ACK/NACK */
+ /*      214 */    { dissect_pfcp_cisco_packet_measurement },                    /* PFCP_IE_PACKET_MEASUREMENT */
+ /*      215 */    { dissect_pfcp_cisco_extended_measurement },                  /* PFCP_IE_EXTENDED_MEASUREMENT_METHOD */
+ /*      216 */    { dissect_pfcp_cisco_recalculate_measurement },               /* PFCP_IE_RECALCULATE_MEASUREMENT */
+ /*      217 */    { dissect_pfcp_cisco_sub_info },                              /* PFCP_IE_SUB_INFO */
+ /*      218 */    { dissect_pfcp_cisco_intr_info },                             /* PFCP_IE_INTR_INFO */
+ /*      219 */    { dissect_pfcp_cisco_node_capability },                       /* PFCP_IE_NODE_CAPABILITY */
+ /*      220 */    { NULL },
+ /*      221 */    { NULL },
+ /*      222 */    { NULL },
+ /*      223 */    { dissect_pfcp_cisco_charging_params },                       /* PFCP_IE_CHARGING_PARAMS */
+ /*      224 */    { dissect_pfcp_cisco_gy_offline_charge },                     /* PFCP_IE_GY_OFFLINE_CHARGE */
+ /*      225 */    { NULL },
+ /*      226 */    { NULL },
+ /*      227 */    { NULL },
+ /*      228 */    { NULL },
+ /*      229 */    { NULL },
+ /*      230 */    { NULL },
+ /*      231 */    { NULL },
+ /*      232 */    { NULL },
+ /*      233 */    { NULL },
+ /*      234 */    { NULL },
+ /*      235 */    { NULL },
+ /*      236 */    { NULL },
+ /*      237 */    { NULL },
+ /*      238 */    { NULL },
+ /*      239 */    { NULL },
+ /*      240 */    { NULL },
+ /*      241 */    { NULL },
+ /*      242 */    { NULL },
+ /*      243 */    { NULL },
+ /*      244 */    { NULL },
+ /*      245 */    { NULL },
+ /*      246 */    { NULL },
+ /*      247 */    { NULL },
+ /*      248 */    { NULL },
+ /*      249 */    { NULL },
+ /*      250 */    { NULL },
+ /*      251 */    { NULL },
+ /*      252 */    { NULL },
+ /*      253 */    { NULL },
+ /*      254 */    { NULL },
+ /*      255 */    { dissect_pfcp_cisco_inner_packet_marking },           /* INNER PACKET MARKING */
+ /*      256 */    { NULL },
+ /*      257 */    { NULL },
+ /*      258 */    { NULL },
+ /*      259 */    { NULL },
+ /*      260 */    { NULL },
+ /*      261 */    { NULL },
+ /*      262 */    { NULL },
+ /*      263 */    { NULL },
+ /*      264 */    { NULL },
+ /*      265 */    { NULL },
+ /*      255 */    { dissect_pfcp_cisco_transport_level_marking },        /* TRANSPORT LEVEL MARKING OPTIONS */
+     { NULL },                                                        /* End of List */
+ };
+ 
+ #define IE_COMPRESSED(spare) ((spare & 0x08) == 8)
+ 
  #define NUM_PFCP_IES (sizeof(pfcp_ies)/sizeof(pfcp_ie_t))
+ #define PCFP_CISCO_FIRST_IE 201
+ #define NUM_PFCP_CISCO_IES (sizeof(pfcp_cisco_ies)/sizeof(pfcp_ie_t))
+ 
  /* Set up the array to hold "etts" for each IE*/
  gint ett_pfcp_elem[NUM_PFCP_IES-1];
+ gint ett_pfcfp_cisco_elem[NUM_PFCP_CISCO_IES - 1];
  
  static pfcp_msg_hash_t *
  pfcp_match_response(tvbuff_t * tvb, packet_info * pinfo, proto_tree * tree, gint seq_nr, guint msgtype, pfcp_conv_info_t *pfcp_info, guint8 last_cause)
*************** dissect_pfcp_additional_monitoring_time(
*** 5771,5985 ****
      dissect_pfcp_grouped_ie(tvb, pinfo, tree, item, length, message_type, ett_pfcp_elem[PFCP_IE_ADDITIONAL_MONITORING_TIME], args);
  }
  
  static void
! dissect_pfcp_ies_common(tvbuff_t * tvb, packet_info * pinfo, proto_tree * tree, gint offset, guint8 message_type, pfcp_session_args_t *args)
  {
!     proto_tree *ie_tree;
!     proto_item *ti;
!     tvbuff_t   *ie_tvb;
!     guint16 type, length;
!     guint16 enterprise_id;
  
!     /* 8.1.1    Information Element Format */
!     /*
!     Octets      8   7   6   5   4   3   2   1
!     1 to 2      Type = xxx (decimal)
!     3 to 4      Length = n
!     p to (p+1)  Enterprise ID
!     k to (n+4)  IE specific data or content of a grouped IE
  
!     If the Bit 8 of Octet 1 is not set, this indicates that the IE is defined by 3GPP and the Enterprise ID is absent.
!     If Bit 8 of Octet 1 is set, this indicates that the IE is defined by a vendor and the Enterprise ID is present
!     identified by the Enterprise ID
!     */
  
!     /*Enterprise ID : if the IE type value is within the range of 32768 to 65535,
!      * this field shall contain the IANA - assigned "SMI Network Management Private Enterprise Codes"
!      * value of the vendor defining the IE.
!      */
!     /* Length: this field contains the length of the IE excluding the first four octets, which are common for all IEs */
  
!     /* Process the IEs*/
!     while (offset < (gint)tvb_reported_length(tvb)) {
!         /* Octet 1 -2 */
!         type = tvb_get_ntohs(tvb, offset);
!         length = tvb_get_ntohs(tvb, offset + 2);
  
!         if ((type & 0x8000) == 0x8000 ) {
!             enterprise_id = tvb_get_ntohs(tvb, offset + 4);
!             ie_tree = proto_tree_add_subtree_format(tree, tvb, offset, 4 + length, ett_pfcp_ie, &ti, "Enterprise %s specific IE: %u",
!                 try_enterprises_lookup(enterprise_id),
!                 type);
  
!             proto_tree_add_item(ie_tree, hf_pfcp2_enterprise_ie, tvb, offset, 2, ENC_BIG_ENDIAN);
              offset += 2;
  
!             proto_tree_add_item(ie_tree, hf_pfcp2_ie_len, tvb, offset, 2, ENC_BIG_ENDIAN);
!             offset += 2;
  
!             /* Bit 8 of Octet 1 is set, this indicates that the IE is defined by a vendor and the Enterprise ID is present */
!             proto_tree_add_item(ie_tree, hf_pfcp_enterprise_id, tvb, offset, 2, ENC_BIG_ENDIAN);
  
!             /*
!             * 5.6.3    Modifying the Rules of an Existing PFCP Session
!             *
!             * Updating the Rule including the IEs to be removed with a null length,
!             * e.g. by including the Update URR IE in the PFCP Session Modification Request
!             * with the IE(s) to be removed with a null length.
!             */
!             if (length == 0) {
!                 proto_item_append_text(ti, "[IE to be removed]");
  
!                 /* Adding offset for EnterpriseID as Bit 8 of Octet 1 is set, the Enterprise ID is present */
!                 offset += 2;
  
!             } else {
!                 /* give the whole IE to the subdissector */
!                 ie_tvb = tvb_new_subset_length(tvb, offset - 4, length+4);
!                 if (!dissector_try_uint_new(pfcp_enterprise_ies_dissector_table, enterprise_id, ie_tvb, pinfo, ie_tree, FALSE, ti)) {
!                     proto_tree_add_item(ie_tree, hf_pfcp_enterprise_data, ie_tvb, 6, -1, ENC_NA);
!                 }
!             }
!             offset += length;
!         } else {
!             int tmp_ett;
!             if (type < (NUM_PFCP_IES - 1)) {
!                 tmp_ett = ett_pfcp_elem[type];
!             } else {
!                 tmp_ett = ett_pfcp_ie;
              }
-             ie_tree = proto_tree_add_subtree_format(tree, tvb, offset, 4 + length, tmp_ett, &ti, "%s : ",
-                 val_to_str_ext_const(type, &pfcp_ie_type_ext, "Unknown"));
  
!             proto_tree_add_item(ie_tree, hf_pfcp2_ie, tvb, offset, 2, ENC_BIG_ENDIAN);
!             offset += 2;
!             proto_tree_add_item(ie_tree, hf_pfcp2_ie_len, tvb, offset, 2, ENC_BIG_ENDIAN);
!             offset += 2;
  
!             /*
!             * 5.6.3    Modifying the Rules of an Existing PFCP Session
!             *
!             * Updating the Rule including the IEs to be removed with a null length,
!             * e.g. by including the Update URR IE in the PFCP Session Modification Request
!             * with the IE(s) to be removed with a null length.
!             */
!             if( length == 0 ) {
!                 proto_item_append_text(ti, "[IE to be removed]");
!             } else {
!                 if (type < (NUM_PFCP_IES -1)) {
!                     ie_tvb = tvb_new_subset_length(tvb, offset, length);
!                     if(pfcp_ies[type].decode){
!                         (*pfcp_ies[type].decode) (ie_tvb, pinfo, ie_tree, ti, length, message_type, args);
!                     } else {
!                         /* NULL function pointer, we have no decoding function*/
!                         proto_tree_add_expert(ie_tree, pinfo, &ei_pfcp_ie_not_decoded_null, tvb, offset, length);
!                     }
!                 } else {
!                     /* IE id outside of array, We have no decoding function for it */
!                     proto_tree_add_expert(ie_tree, pinfo, &ei_pfcp_ie_not_decoded_to_large, tvb, offset, length);
!                 }
              }
              offset += length;
          }
!     }
  }
  
! static int
! dissect_pfcp(tvbuff_t * tvb, packet_info * pinfo, proto_tree * tree, void *data _U_)
  {
-     proto_item          *item;
-     proto_tree          *sub_tree;
      int                  offset = 0;
!     guint64              pfcp_flags;
!     guint8               message_type, cause_aux;
!     guint32              length;
!     guint32              length_remaining;
!     int                  seq_no = 0;
!     conversation_t      *conversation;
!     pfcp_conv_info_t    *pfcp_info;
!     pfcp_session_args_t *args = NULL;
!     pfcp_hdr_t          *pfcp_hdr = NULL;
  
!     static const int * pfcp_hdr_flags[] = {
!         &hf_pfcp_version,
!         &hf_pfcp_spare_b4,
!         &hf_pfcp_spare_b3,
!         &hf_pfcp_spare_b2,
!         &hf_pfcp_mp_flag,
!         &hf_pfcp_s_flag,
!         NULL
!     };
  
!     pfcp_hdr = wmem_new0(wmem_packet_scope(), pfcp_hdr_t);
  
!     /* Setting the SEID to -1 to say that the SEID is not valid for this packet */
!     pfcp_hdr->seid = -1;
  
!     col_set_str(pinfo->cinfo, COL_PROTOCOL, "PFCP");
!     col_clear(pinfo->cinfo, COL_INFO);
  
!     message_type = tvb_get_guint8(tvb, 1);
!     col_set_str(pinfo->cinfo, COL_INFO, val_to_str_ext_const(message_type, &pfcp_message_type_ext, "Unknown"));
!     if (g_pfcp_session) {
!         args = wmem_new0(wmem_packet_scope(), pfcp_session_args_t);
!         args->last_cause = 1;                                         /* It stores the last cause decoded. Cause accepted by default */
!         /* We create the auxiliary lists */
!         args->seid_list = wmem_list_new(wmem_packet_scope());
!         args->ip_list = wmem_list_new(wmem_packet_scope());
      }
  
!     /* Do we have a conversation for this connection? */
!     conversation = find_or_create_conversation(pinfo);
  
!     /* Do we already know this conversation? */
!     pfcp_info = (pfcp_conv_info_t *)conversation_get_proto_data(conversation, proto_pfcp);
!     if (pfcp_info == NULL) {
!         /* No. Attach that information to the conversation,
!         * and add it to the list of information structures.
!         */
!         pfcp_info = wmem_new(wmem_file_scope(), pfcp_conv_info_t);
!         /* Request/response matching tables */
!         pfcp_info->matched = wmem_map_new(wmem_file_scope(), pfcp_sn_hash, pfcp_sn_equal_matched);
!         pfcp_info->unmatched = wmem_map_new(wmem_file_scope(), pfcp_sn_hash, pfcp_sn_equal_unmatched);
  
!         conversation_add_proto_data(conversation, proto_pfcp, pfcp_info);
!     }
  
!     item = proto_tree_add_item(tree, proto_pfcp, tvb, 0, -1, ENC_NA);
!     sub_tree = proto_item_add_subtree(item, ett_pfcp);
  
!     /* 7.2.2    Message Header */
!     /*
!         Octet     8     7     6     5     4     3     2     1
!           1    | Version         |Spare|Spare|Spare|  MP  |  S  |
!           2    |        Message Type                            |
!           3    |        Message Length (1st Octet)              |
!           4    |        Message Length (2nd Octet)              |
!         m to   | If S flag is set to 1, then SEID shall be      |
!         k(m+7) | placed into octets 5-12. Otherwise, SEID field |
!                | is not present at all.                         |
!         n to   | Sequence Number                                |
!         (n+2)  |                                                |
!         (n+3)  |         Spare                                  |
  
!     */
!     /* Octet 1 */
!     proto_tree_add_bitmask_with_flags_ret_uint64(sub_tree, tvb, offset, hf_pfcp_hdr_flags,
!         ett_pfcp_flags, pfcp_hdr_flags, ENC_BIG_ENDIAN, BMT_NO_FALSE | BMT_NO_INT, &pfcp_flags);
      offset += 1;
  
!     /* Octet 2 Message Type */
!     pfcp_hdr->message = tvb_get_guint8(tvb, offset);
!     proto_tree_add_uint(sub_tree, hf_pfcp_msg_type, tvb, offset, 1, pfcp_hdr->message);
      offset += 1;
  
!     /* Octet 3 - 4 Message Length */
!     proto_tree_add_item_ret_uint(sub_tree, hf_pfcp_msg_length, tvb, offset, 2, ENC_BIG_ENDIAN, &length);
!     offset += 2;
!     /*
!      * The length field shall indicate the length of the message in octets
!      * excluding the mandatory part of the PFCP header (the first 4 octets).
!      */
      length_remaining = tvb_reported_length_remaining(tvb, offset);
      if (length != length_remaining) {
          proto_tree_add_expert_format(sub_tree, pinfo, &ei_pfcp_ie_encoding_error, tvb, offset, -1, "Invalid Length for the message: %d instead of %d", length, length_remaining);
--- 6036,6732 ----
      dissect_pfcp_grouped_ie(tvb, pinfo, tree, item, length, message_type, ett_pfcp_elem[PFCP_IE_ADDITIONAL_MONITORING_TIME], args);
  }
  
+ // Cisco IEs
  static void
! dissect_pfcp_cisco_update_addtl_forward_params(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, proto_item *item, guint16 length, guint8 message_type, pfcp_session_args_t *args)
  {
!     dissect_pfcp_grouped_ie(tvb, pinfo, tree, item, length, message_type, ett_pfcfp_cisco_elem[PFCP_IE_CISCO_UPDATE_ADDNL_FORW_PARAMS - PCFP_CISCO_FIRST_IE], args);
! }
  
! static void
! dissect_pfcp_cisco_config_action(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, proto_item *item _U_, guint16 length, guint8 message_type _U_, pfcp_session_args_t *args _U_)
! {
!     int offset = 0;
  
!     proto_tree_add_item(tree, hf_pfcp_cisco_config_action, tvb, offset, 1, ENC_NA);
!     offset += 1;
  
!     if (offset < length) {
!         proto_tree_add_expert(tree, pinfo, &ei_pfcp_ie_data_not_decoded, tvb, offset, -1);
!     }
  
!     return;
! }
  
! static void
! dissect_pfcp_cisco_correlation_id(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, proto_item *item _U_, guint16 length, guint8 message_type _U_, pfcp_session_args_t *args _U_)
! {
!     int offset = 0;
  
!     proto_tree_add_item(tree, hf_pfcp_cisco_correlation_id, tvb, offset, 2, ENC_BIG_ENDIAN);
      offset += 2;
  
!      if (offset < length) {
!         proto_tree_add_expert(tree, pinfo, &ei_pfcp_ie_data_not_decoded, tvb, offset, -1);
!     }
  
!     return;
! }
  
! static void
! dissect_pfcp_cisco_sub_part_number(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, proto_item *item _U_, guint16 length, guint8 message_type _U_, pfcp_session_args_t *args _U_)
! {
!     int offset = 0;
  
!     proto_tree_add_item(tree, hf_pfcp_cisco_sub_part_number, tvb, offset, 1, ENC_NA);
!     offset += 1;
  
!     if (offset < length) {
!         proto_tree_add_expert(tree, pinfo, &ei_pfcp_ie_data_not_decoded, tvb, offset, -1);
      }
  
!     return;
! }
  
! static void
! dissect_pfcp_cisco_sub_part_index(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, proto_item *item _U_, guint16 length, guint8 message_type _U_, pfcp_session_args_t *args _U_)
! {
!     int offset = 0;
! 
!     proto_tree_add_item(tree, hf_pfcp_cisco_sub_part_index, tvb, offset, 1, ENC_NA);
!     offset += 1;
! 
!     if (offset < length) {
!         proto_tree_add_expert(tree, pinfo, &ei_pfcp_ie_data_not_decoded, tvb, offset, -1);
      }
+ 
+     return;
+ }
+ 
+ static void
+ dissect_pfcp_cisco_content_tlv(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, proto_item *item _U_, guint16 length, guint8 message_type _U_, pfcp_session_args_t *args _U_)
+ {
+     //todo dissect TLV
+     proto_tree_add_item(tree, hf_pfcp_cisco_tlv_content, tvb, 0, length, ENC_NA);
+ }
+ 
+ static void
+ dissect_pfcp_cisco_rbase_name(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, proto_item *item _U_, guint16 length, guint8 message_type _U_, pfcp_session_args_t *args _U_)
+ {
+     int offset = 0;
+ 
+     proto_tree_add_item(tree, hf_pfcp_cisco_rbase_name, tvb, offset, length, ENC_ASCII);
      offset += length;
+ 
+     if (offset < length) {
+         proto_tree_add_expert(tree, pinfo, &ei_pfcp_ie_data_not_decoded, tvb, offset, -1);
      }
!     return;
  }
  
! static void
! dissect_pfcp_cisco_nsh_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, proto_item *item _U_, guint16 length, guint8 message_type _U_, pfcp_session_args_t *args _U_)
  {
      int offset = 0;
!     guint32 msdisdnLen = 0, imsiLen = 0, bitoctet = 0;
  
!     proto_tree_add_item_ret_uint(tree, hf_pfcp_cisco_bitoctet, tvb, offset, 1, ENC_NA, &bitoctet);
!     offset += 1;
  
!     if (bitoctet & 0x1) {
!         proto_tree_add_item_ret_uint(tree, hf_pfcp_cisco_msisdn_len, tvb, offset, 1, ENC_BIG_ENDIAN, &msdisdnLen);
!         offset += 1;
  
!         proto_tree_add_item(tree, hf_pfcp_cisco_msisdn_val, tvb, offset, msdisdnLen, ENC_NA);
!         offset += msdisdnLen;
!     }
  
!     if (bitoctet & 0x2) {
!         proto_tree_add_item_ret_uint(tree, hf_pfcp_cisco_imsi_len, tvb, offset, 1, ENC_BIG_ENDIAN, &imsiLen);
!         offset += 1;
  
!         proto_tree_add_item(tree, hf_pfcp_cisco_imsi_val, tvb, offset, imsiLen, ENC_NA);
!         offset += imsiLen;
      }
  
!     if (offset < length) {
!         proto_tree_add_expert(tree, pinfo, &ei_pfcp_ie_data_not_decoded, tvb, offset, -1);
!     }
  
!     return;
! }
  
! static void
! dissect_pfcp_cisco_stats_request(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, proto_item *item, guint16 length, guint8 message_type, pfcp_session_args_t *args)
! {
!     dissect_pfcp_grouped_ie(tvb, pinfo, tree, item, length, message_type, ett_pfcfp_cisco_elem[PFCP_IE_CISCO_STATS_REQ - PCFP_CISCO_FIRST_IE], args);
! }
  
! static void
! dissect_pfcp_cisco_query_params(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, proto_item *item _U_, guint16 length, guint8 message_type _U_, pfcp_session_args_t *args _U_)
! {
!     int offset = 0;
!     guint32 len;
  
!     proto_tree_add_item(tree, hf_pfcp_cisco_entity_type, tvb, offset, 1, ENC_NA);
!     offset += 1;
  
!     // todo convert to bitmask
!     proto_tree_add_item(tree, hf_pfcp_cisco_query_type, tvb, offset, 1, ENC_NA);
      offset += 1;
  
!     proto_tree_add_item_ret_uint(tree, hf_pfcp_cisco_entity_name_len, tvb, offset, 1, ENC_BIG_ENDIAN, &len);
      offset += 1;
  
!     proto_tree_add_item(tree, hf_pfcp_cisco_entity_name_val, tvb, offset, len, ENC_ASCII);
!     offset += len;
! 
!     if (offset < length) {
!         proto_tree_add_expert(tree, pinfo, &ei_pfcp_ie_data_not_decoded, tvb, offset, -1);
!     }
! 
!     return;    
! }
! 
! static void
! dissect_pfcp_cisco_classifier_params(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, proto_item *item _U_, guint16 length, guint8 message_type _U_, pfcp_session_args_t *args _U_)
! {
!     int offset = 0;
!     guint32 len;
! 
!     proto_tree_add_item(tree, hf_pfcp_cisco_classifier_type, tvb, offset, 1, ENC_NA);
!     offset += 1;
! 
!     proto_tree_add_item(tree, hf_pfcp_cisco_classifier_type, tvb, offset, 1, ENC_NA);
!     offset += 1;
! 
!     proto_tree_add_item_ret_uint(tree, hf_pfcp_cisco_classifier_len, tvb, offset, 1, ENC_BIG_ENDIAN, &len);
!     offset += 1;
! 
!     proto_tree_add_item(tree, hf_pfcp_cisco_classifier_val, tvb, offset, len, ENC_NA);
!     offset += len;
! 
!     if (offset < length) {
!         proto_tree_add_expert(tree, pinfo, &ei_pfcp_ie_data_not_decoded, tvb, offset, -1);
!     }
! 
!     return;        
! }
! 
! static void
! dissect_pfcp_cisco_stats_response(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, proto_item *item _U_, guint16 length, guint8 message_type _U_, pfcp_session_args_t *args _U_)
! {
!     int offset = 0;
! 
!     proto_tree_add_item(tree, hf_pfcp_cisco_response_entity_type, tvb, offset, 1, ENC_NA);
!     offset += 1;
! 
!     proto_tree_add_item(tree, hf_pfcp_cisco_query_type, tvb, offset, 1, ENC_NA);
!     offset += 1;
! 
!     proto_tree_add_item(tree, hf_pfcp_cisco_response_part_number, tvb, offset, 1, ENC_NA);
!     offset += 1;
! 
!     proto_tree_add_item(tree, hf_pfcp_cisco_response_total_part_number, tvb, offset, 1, ENC_NA);
!     offset += 1;
! 
!     if (offset < length) {
!         proto_tree_add_expert(tree, pinfo, &ei_pfcp_ie_data_not_decoded, tvb, offset, -1);
!     }
! 
!     return;      
! }
! 
! static void
! dissect_pfcp_cisco_response_ack(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, proto_item *item _U_, guint16 length, guint8 message_type _U_, pfcp_session_args_t *args _U_)
! {
!     int offset = 0;
!     int value;
! 
!     value = tvb_get_guint8(tvb, offset);
!     proto_tree_add_item(tree, hf_pfcp_cisco_response_type, tvb, offset, 1, ENC_NA);
!     offset += 1;
! 
!     proto_tree_add_item(tree, hf_pfcp_cisco_response_missing_parts, tvb, offset, length - 1, ENC_NA);
! 
!     proto_item_append_text(item, "%s", val_to_str_const(value, response_ack_nack, "Unknown"));
! 
!     return;    
! }
! 
! static void
! dissect_pfcp_cisco_packet_measurement(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, proto_item *item _U_, guint16 length, guint8 message_type _U_, pfcp_session_args_t *args _U_)
! {
!     int offset = 0;
!     guint32 info;
! 
!     // Todo convert to bitmask
!     proto_tree_add_item_ret_uint(tree, hf_pfcp_cisco_spare, tvb, offset, 1, ENC_BIG_ENDIAN, &info);
!     offset += 1;
! 
!     if (info & 0x1) {
!         proto_tree_add_item(tree, hf_pfcp_cisco_packet_measurement_total, tvb, offset, 8, ENC_NA);
!         offset += 8;
!     }
! 
!     if (info & 0x2) {
!         proto_tree_add_item(tree, hf_pfcp_cisco_packet_measurement_uplink, tvb, offset, 8, ENC_NA);
!         offset += 8;
!     }
! 
!     if (info & 0x4) {
!         proto_tree_add_item(tree, hf_pfcp_cisco_packet_measurement_downlink, tvb, offset, 8, ENC_NA);
!         offset += 8;
!     }
! 
!     if (offset < length) {
!         proto_tree_add_expert(tree, pinfo, &ei_pfcp_ie_data_not_decoded, tvb, offset, -1);
!     }
!     
!     return;        
! }
! 
! static void
! dissect_pfcp_cisco_extended_measurement(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, proto_item *item _U_, guint16 length, guint8 message_type _U_, pfcp_session_args_t *args _U_)
! {
!     proto_tree_add_item(tree, hf_pfcp_cisco_tlv_content, tvb, 0, length, ENC_NA);
! }
! 
! static void
! dissect_pfcp_cisco_recalculate_measurement(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, proto_item *item _U_, guint16 length, guint8 message_type _U_, pfcp_session_args_t *args _U_)
! {
!     proto_tree_add_item(tree, hf_pfcp_cisco_tlv_content, tvb, 0, length, ENC_NA);
! }
! 
! static void
! dissect_pfcp_cisco_sub_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, proto_item *item _U_, guint16 length, guint8 message_type _U_, pfcp_session_args_t *args _U_)
! {
!     int offset = 0;
!     guint32 msdisdnLen = 0, imsiLen = 0, imeiLen = 0, bitoctet = 0;
! 
!     proto_tree_add_item_ret_uint(tree, hf_pfcp_cisco_bitoctet, tvb, offset, 1, ENC_NA, &bitoctet);
!     offset += 1;
! 
!     if (bitoctet & 0x1) {
!         proto_tree_add_item_ret_uint(tree, hf_pfcp_cisco_imsi_len, tvb, offset, 1, ENC_BIG_ENDIAN, &imsiLen);
!         offset += 1;
! 
!         proto_tree_add_item(tree, hf_pfcp_cisco_imsi_val, tvb, offset, imsiLen, ENC_NA);
!         offset += imsiLen;
!     }
! 
!     if (bitoctet & 0x2) {
!         proto_tree_add_item_ret_uint(tree, hf_pfcp_cisco_msisdn_len, tvb, offset, 1, ENC_BIG_ENDIAN, &msdisdnLen);
!         offset += 1;
!     
!         proto_tree_add_item(tree, hf_pfcp_cisco_msisdn_val, tvb, offset, msdisdnLen, ENC_NA);
!         offset += msdisdnLen;
!     }
! 
!     if (bitoctet & 0x4) {
!         proto_tree_add_item_ret_uint(tree, hf_pfcp_cisco_imei_len, tvb, offset, 1, ENC_BIG_ENDIAN, &imeiLen);
!         offset += 1;
! 
!         proto_tree_add_item(tree, hf_pfcp_cisco_imei_val, tvb, offset, imeiLen, ENC_NA);
!         offset += imsiLen;
!     }
! 
!     if (bitoctet & 0x8) {
!         proto_tree_add_item(tree, hf_pfcp_cisco_callid, tvb, offset, 4, ENC_NA);
!         offset += 4;
!     }
! 
!     if (offset < length) {
!         proto_tree_add_expert(tree, pinfo, &ei_pfcp_ie_data_not_decoded, tvb, offset, -1);
!     }
! 
!     return;    
! }
! 
! static void
! dissect_pfcp_cisco_intr_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, proto_item *item _U_, guint16 length, guint8 message_type _U_, pfcp_session_args_t *args _U_)
! {
!     int offset = 0;
!     guint32 len = 0, bitoctet;
! 
!     proto_tree_add_item_ret_uint(tree, hf_pfcp_cisco_bitoctet, tvb, offset, 1, ENC_NA, &bitoctet);
!     offset += 1;
! 
!     if (bitoctet & 0x1) {
!         proto_tree_add_item(tree, hf_pfcp_cisco_intercept_id, tvb, offset, 4, ENC_NA);
!         offset += 4;
!     }
! 
!     if (bitoctet & 0x2) {
!         proto_tree_add_item(tree, hf_pfcp_cisco_charging_id, tvb, offset, 4, ENC_NA);
!         offset += 4;
!     }
! 
!     if (bitoctet & 0x4) {
!         proto_tree_add_item(tree, hf_pfcp_cisco_bearer_id, tvb, offset, 4, ENC_NA);
!         offset += 4;
!     }
! 
!     if (bitoctet & 0x8) {    
!         proto_tree_add_item_ret_uint(tree, hf_pfcp_cisco_context_name_len, tvb, offset, 1, ENC_BIG_ENDIAN, &len);
!         offset += 1;
! 
!         proto_tree_add_item(tree, hf_pfcp_cisco_context_name_val, tvb, offset, len, ENC_ASCII);
!         offset += len;
!     }
! 
!     if (offset < length) {
!         proto_tree_add_expert(tree, pinfo, &ei_pfcp_ie_data_not_decoded, tvb, offset, -1);
!     }
! 
!     return;    
! }
! 
! static void
! dissect_pfcp_cisco_node_capability(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, proto_item *item _U_, guint16 length, guint8 message_type _U_, pfcp_session_args_t *args _U_)
! {
!     int offset = 0;
! 
!     proto_tree_add_item(tree, hf_pfcp_cisco_node_capability_max_session, tvb, offset, 4, ENC_NA);
!     offset += 4;
! 
!     if (offset < length) {
!         proto_tree_add_expert(tree, pinfo, &ei_pfcp_ie_data_not_decoded, tvb, offset, -1);
!     }
! 
!     return;  
! }
! 
! static void
! dissect_pfcp_cisco_charging_params(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, proto_item *item _U_, guint16 length, guint8 message_type _U_, pfcp_session_args_t *args _U_)
! {
!     int offset = 0;
!     guint32 len = 0;
! 
!     proto_tree_add_item(tree, hf_pfcp_cisco_charging_chars, tvb, offset, 2, ENC_NA);
!     offset += 2;
! 
!     proto_tree_add_item_ret_uint(tree, hf_pfcp_cisco_gtpp_group_name_len, tvb, offset, 1, ENC_NA, &len);
!     offset += 1;
! 
!     if (len > 0){
!         proto_tree_add_item(tree, hf_pfcp_cisco_gtpp_group_name_val, tvb, offset, len, ENC_NA);
!         offset += len;
!     }
! 
!     proto_tree_add_item(tree, hf_pfcp_cisco_gtpp_context_id, tvb, offset, 4, ENC_NA);
!     offset += 4;
! 
!     proto_tree_add_item_ret_uint(tree, hf_pfcp_cisco_policy_name_len, tvb, offset, 1, ENC_NA, &len);
!     offset += 1;
! 
!     if (len > 0){
!         proto_tree_add_item(tree, hf_pfcp_cisco_policy_name, tvb, offset, len, ENC_NA);
!         offset += len;
!     }
! 
!     proto_tree_add_item(tree, hf_pfcp_cisco_policy_type, tvb, offset, 4, ENC_NA);
!     offset += 4;
! 
!     proto_tree_add_item(tree, hf_pfcp_cisco_diameter_interim_interval, tvb, offset, 4, ENC_NA);
!     offset += 4;
! 
!     proto_tree_add_item_ret_uint(tree, hf_pfcp_cisco_aaa_group_name_len, tvb, offset, 1, ENC_NA, &len);
!     offset += 1;
! 
!     if (len > 0){
!         proto_tree_add_item(tree, hf_pfcp_cisco_aaa_group_name_val, tvb, offset, len, ENC_NA);
!         offset += len;
!     }
! 
!     proto_tree_add_item(tree, hf_pfcp_cisco_aaa_group_context_id, tvb, offset, 4, ENC_NA);
!     offset += 4;
! 
!     proto_tree_add_item(tree, hf_pfcp_cisco_radius_interim_interval, tvb, offset, 4, ENC_NA);
!     offset += 4;
! 
!     proto_tree_add_item(tree, hf_pfcp_cisco_gy_offline_charging, tvb, offset, 1, ENC_NA);
!     offset += 1;
! 
!     proto_tree_add_item(tree, hf_pfcp_cisco_gtpp_dictionnary, tvb, offset, 1, ENC_NA);
!     offset += 1;
! 
!     if (offset < length) {
!         proto_tree_add_expert(tree, pinfo, &ei_pfcp_ie_data_not_decoded, tvb, offset, -1);
!     }
! 
!     return;      
! }
! 
! static void
! dissect_pfcp_cisco_gy_offline_charge(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, proto_item *item _U_, guint16 length, guint8 message_type _U_, pfcp_session_args_t *args _U_)
! {
!     int offset = 0;
! 
!     proto_tree_add_item(tree, hf_pfcp_cisco_gy_offline_charging_status, tvb, offset, 1, ENC_NA);
!     offset += 1;
! 
!     if (offset < length) {
!         proto_tree_add_expert(tree, pinfo, &ei_pfcp_ie_data_not_decoded, tvb, offset, -1);
!     }
! 
!     return;      
! }
! 
! static void
! dissect_pfcp_cisco_inner_packet_marking(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, proto_item *item _U_, guint16 length, guint8 message_type _U_, pfcp_session_args_t *args _U_)
! {
!     int offset = 0;
! 
!     proto_tree_add_item(tree, hf_pfcp_cisco_traffic_class, tvb, offset, 2, ENC_NA);
!     offset += 2;
! 
!     if (offset < length) {
!         proto_tree_add_expert(tree, pinfo, &ei_pfcp_ie_data_not_decoded, tvb, offset, -1);
!     }
! 
!     return;      
! }
! 
! static void
! dissect_pfcp_cisco_transport_level_marking(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, proto_item *item _U_, guint16 length, guint8 message_type _U_, pfcp_session_args_t *args _U_)
! {
!     int offset = 0;
! 
!     proto_tree_add_item(tree, hf_pfcp_cisco_copy_inner_outer_flag, tvb, offset, 1, ENC_NA);
!     offset += 1;
! 
!     if (offset < length) {
!         proto_tree_add_expert(tree, pinfo, &ei_pfcp_ie_data_not_decoded, tvb, offset, -1);
!     }
! 
!     return;      
! }
! 
! // end of cisco IE
! 
! static void
! dissect_pfcp_ies_common(tvbuff_t * tvb, packet_info * pinfo, proto_tree * tree, gint offset, guint8 message_type, pfcp_session_args_t *args)
! {
!     proto_tree *ie_tree;
!     proto_item *ti;
!     tvbuff_t   *ie_tvb;
!     guint16 type, length;
!     guint16 enterprise_id;
! 
!     /* 8.1.1    Information Element Format */
!     /*
!     Octets      8   7   6   5   4   3   2   1
!     1 to 2      Type = xxx (decimal)
!     3 to 4      Length = n
!     p to (p+1)  Enterprise ID
!     k to (n+4)  IE specific data or content of a grouped IE
! 
!     If the Bit 8 of Octet 1 is not set, this indicates that the IE is defined by 3GPP and the Enterprise ID is absent.
!     If Bit 8 of Octet 1 is set, this indicates that the IE is defined by a vendor and the Enterprise ID is present
!     identified by the Enterprise ID
!     */
! 
!     /*Enterprise ID : if the IE type value is within the range of 32768 to 65535,
!      * this field shall contain the IANA - assigned "SMI Network Management Private Enterprise Codes"
!      * value of the vendor defining the IE.
!      */
!     /* Length: this field contains the length of the IE excluding the first four octets, which are common for all IEs */
! 
!     /* Process the IEs*/
!     while (offset < (gint)tvb_reported_length(tvb)) {
!         /* Octet 1 -2 */
!         type = tvb_get_ntohs(tvb, offset);
!         length = tvb_get_ntohs(tvb, offset + 2);
! 
!         if ((type & 0x8000) == 0x8000 ) {
!             enterprise_id = tvb_get_ntohs(tvb, offset + 4);
!             ie_tree = proto_tree_add_subtree_format(tree, tvb, offset, 4 + length, ett_pfcp_ie, &ti, "Enterprise %s specific IE: %u",
!                 try_enterprises_lookup(enterprise_id),
!                 type);
! 
!             proto_tree_add_item(ie_tree, hf_pfcp2_enterprise_ie, tvb, offset, 2, ENC_BIG_ENDIAN);
!             offset += 2;
! 
!             proto_tree_add_item(ie_tree, hf_pfcp2_ie_len, tvb, offset, 2, ENC_BIG_ENDIAN);
!             offset += 2;
! 
!             /* Bit 8 of Octet 1 is set, this indicates that the IE is defined by a vendor and the Enterprise ID is present */
!             proto_tree_add_item(ie_tree, hf_pfcp_enterprise_id, tvb, offset, 2, ENC_BIG_ENDIAN);
! 
!             /*
!             * 5.6.3    Modifying the Rules of an Existing PFCP Session
!             *
!             * Updating the Rule including the IEs to be removed with a null length,
!             * e.g. by including the Update URR IE in the PFCP Session Modification Request
!             * with the IE(s) to be removed with a null length.
!             */
!             if (length == 0) {
!                 proto_item_append_text(ti, "[IE to be removed]");
! 
!                 /* Adding offset for EnterpriseID as Bit 8 of Octet 1 is set, the Enterprise ID is present */
!                 offset += 2;
! 
!             } else {
!                 /* give the whole IE to the subdissector */
!                 ie_tvb = tvb_new_subset_length(tvb, offset - 4, length+4);
!                 if (!dissector_try_uint_new(pfcp_enterprise_ies_dissector_table, enterprise_id, ie_tvb, pinfo, ie_tree, FALSE, ti)) {
!                     proto_tree_add_item(ie_tree, hf_pfcp_enterprise_data, ie_tvb, 6, -1, ENC_NA);
!                 }
!             }
!             offset += length;
!         } else {
!             int tmp_ett;
!             if (type < (NUM_PFCP_IES - 1)) {
!                 tmp_ett = ett_pfcp_elem[type];
!             } else if ((type >= PCFP_CISCO_FIRST_IE) && (type < PCFP_CISCO_FIRST_IE + NUM_PFCP_CISCO_IES - 1)) {
!                 tmp_ett = ett_pfcfp_cisco_elem[type - PCFP_CISCO_FIRST_IE];
!             } else {
!                 tmp_ett = ett_pfcp_ie;
!             }
!             ie_tree = proto_tree_add_subtree_format(tree, tvb, offset, 4 + length, tmp_ett, &ti, "%s : ",
!                 val_to_str_ext_const(type, &pfcp_ie_type_ext, "Unknown"));
! 
!             proto_tree_add_item(ie_tree, hf_pfcp2_ie, tvb, offset, 2, ENC_BIG_ENDIAN);
!             offset += 2;
!             proto_tree_add_item(ie_tree, hf_pfcp2_ie_len, tvb, offset, 2, ENC_BIG_ENDIAN);
!             offset += 2;
! 
!             /*
!             * 5.6.3    Modifying the Rules of an Existing PFCP Session
!             *
!             * Updating the Rule including the IEs to be removed with a null length,
!             * e.g. by including the Update URR IE in the PFCP Session Modification Request
!             * with the IE(s) to be removed with a null length.
!             */
!             if( length == 0 ) {
!                 proto_item_append_text(ti, "[IE to be removed]");
!             } else {
!                 if (type < (NUM_PFCP_IES -1)) {
!                     ie_tvb = tvb_new_subset_length(tvb, offset, length);
!                     if(pfcp_ies[type].decode){
!                         (*pfcp_ies[type].decode) (ie_tvb, pinfo, ie_tree, ti, length, message_type, args);
!                     } else {
!                         /* NULL function pointer, we have no decoding function*/
!                         proto_tree_add_expert(ie_tree, pinfo, &ei_pfcp_ie_not_decoded_null, tvb, offset, length);
!                     }
!                 } else if ((type >= PCFP_CISCO_FIRST_IE) && (type < PCFP_CISCO_FIRST_IE + NUM_PFCP_CISCO_IES - 1)) {
!                     ie_tvb = tvb_new_subset_length(tvb, offset, length);
!                     if (pfcp_cisco_ies[type - PCFP_CISCO_FIRST_IE].decode){
!                         (*pfcp_cisco_ies[type - PCFP_CISCO_FIRST_IE].decode) (ie_tvb, pinfo, ie_tree, ti, length, message_type, args);
!                     } else {
!                         /* NULL function pointer, we have no decoding function*/
!                         g_print("No Cisco Decoder for %i\n", type);
!                         proto_tree_add_expert(ie_tree, pinfo, &ei_pfcp_ie_not_decoded_null, tvb, offset, length);
!                     }
!                 } else {
!                     /* IE id outside of array, We have no decoding function for it */
!                     g_print("No Decoder for %i\n", type);
!                     proto_tree_add_expert(ie_tree, pinfo, &ei_pfcp_ie_not_decoded_to_large, tvb, offset, length);
!                 }
!             }
!             offset += length;
!         }
!     }
! }
! 
! static int
! dissect_pfcp(tvbuff_t * tvb, packet_info * pinfo, proto_tree * tree, void *data _U_)
! {
!     proto_item          *item;
!     proto_tree          *sub_tree;
!     int                  offset = 0, datalen;
!     guint64              pfcp_flags;
!     guint8               message_type, cause_aux, spare;
!     guint32              length;
!     guint32              length_remaining;
!     int                  seq_no = 0;
!     conversation_t      *conversation;
!     pfcp_conv_info_t    *pfcp_info;
!     pfcp_session_args_t *args = NULL;
!     pfcp_hdr_t          *pfcp_hdr = NULL;
!     tvbuff_t            *next_tvb;
! 
!     static const int * pfcp_hdr_flags[] = {
!         &hf_pfcp_version,
!         &hf_pfcp_spare_b4,
!         &hf_pfcp_spare_b3,
!         &hf_pfcp_spare_b2,
!         &hf_pfcp_mp_flag,
!         &hf_pfcp_s_flag,
!         NULL
!     };
! 
!     pfcp_hdr = wmem_new0(wmem_packet_scope(), pfcp_hdr_t);
! 
!     /* Setting the SEID to -1 to say that the SEID is not valid for this packet */
!     pfcp_hdr->seid = -1;
! 
!     col_set_str(pinfo->cinfo, COL_PROTOCOL, "PFCP");
!     col_clear(pinfo->cinfo, COL_INFO);
! 
!     message_type = tvb_get_guint8(tvb, 1);
!     col_set_str(pinfo->cinfo, COL_INFO, val_to_str_ext_const(message_type, &pfcp_message_type_ext, "Unknown"));
!     if (g_pfcp_session) {
!         args = wmem_new0(wmem_packet_scope(), pfcp_session_args_t);
!         args->last_cause = 1;                                         /* It stores the last cause decoded. Cause accepted by default */
!         /* We create the auxiliary lists */
!         args->seid_list = wmem_list_new(wmem_packet_scope());
!         args->ip_list = wmem_list_new(wmem_packet_scope());
!     }
! 
!     /* Do we have a conversation for this connection? */
!     conversation = find_or_create_conversation(pinfo);
! 
!     /* Do we already know this conversation? */
!     pfcp_info = (pfcp_conv_info_t *)conversation_get_proto_data(conversation, proto_pfcp);
!     if (pfcp_info == NULL) {
!         /* No. Attach that information to the conversation,
!         * and add it to the list of information structures.
!         */
!         pfcp_info = wmem_new(wmem_file_scope(), pfcp_conv_info_t);
!         /* Request/response matching tables */
!         pfcp_info->matched = wmem_map_new(wmem_file_scope(), pfcp_sn_hash, pfcp_sn_equal_matched);
!         pfcp_info->unmatched = wmem_map_new(wmem_file_scope(), pfcp_sn_hash, pfcp_sn_equal_unmatched);
! 
!         conversation_add_proto_data(conversation, proto_pfcp, pfcp_info);
!     }
! 
!     item = proto_tree_add_item(tree, proto_pfcp, tvb, 0, -1, ENC_NA);
!     sub_tree = proto_item_add_subtree(item, ett_pfcp);
! 
!     /* 7.2.2    Message Header */
!     /*
!         Octet     8     7     6     5     4     3     2     1
!           1    | Version         |Spare|Spare|Spare|  MP  |  S  |
!           2    |        Message Type                            |
!           3    |        Message Length (1st Octet)              |
!           4    |        Message Length (2nd Octet)              |
!         m to   | If S flag is set to 1, then SEID shall be      |
!         k(m+7) | placed into octets 5-12. Otherwise, SEID field |
!                | is not present at all.                         |
!         n to   | Sequence Number                                |
!         (n+2)  |                                                |
!         (n+3)  |         Spare                                  |
! 
!     */
!     /* Octet 1 */
!     proto_tree_add_bitmask_with_flags_ret_uint64(sub_tree, tvb, offset, hf_pfcp_hdr_flags,
!         ett_pfcp_flags, pfcp_hdr_flags, ENC_BIG_ENDIAN, BMT_NO_FALSE | BMT_NO_INT, &pfcp_flags);
!     offset += 1;
! 
!     /* Octet 2 Message Type */
!     pfcp_hdr->message = tvb_get_guint8(tvb, offset);
!     proto_tree_add_uint(sub_tree, hf_pfcp_msg_type, tvb, offset, 1, pfcp_hdr->message);
!     offset += 1;
! 
!     /* Octet 3 - 4 Message Length */
!     proto_tree_add_item_ret_uint(sub_tree, hf_pfcp_msg_length, tvb, offset, 2, ENC_BIG_ENDIAN, &length);
!     offset += 2;
!     /*
!      * The length field shall indicate the length of the message in octets
!      * excluding the mandatory part of the PFCP header (the first 4 octets).
!      */
      length_remaining = tvb_reported_length_remaining(tvb, offset);
      if (length != length_remaining) {
          proto_tree_add_expert_format(sub_tree, pinfo, &ei_pfcp_ie_encoding_error, tvb, offset, -1, "Invalid Length for the message: %d instead of %d", length, length_remaining);
*************** dissect_pfcp(tvbuff_t * tvb, packet_info
*** 6007,6012 ****
--- 6754,6760 ----
      proto_tree_add_item_ret_uint(sub_tree, hf_pfcp_seqno, tvb, offset, 3, ENC_BIG_ENDIAN, &seq_no);
      offset += 3;
  
+     spare = tvb_get_guint8(tvb, offset);
      if ((pfcp_flags & 0x2) == 0x2) {
          /* If the "MP" flag is set to "1", then bits 8 to 5 of octet 16 shall indicate the message priority.*/
          proto_tree_add_item(sub_tree, hf_pfcp_mp, tvb, offset, 1, ENC_BIG_ENDIAN);
*************** dissect_pfcp(tvbuff_t * tvb, packet_info
*** 6016,6023 ****
--- 6764,6782 ----
      }
      offset++;
  
+     //Cisco
+     if (IE_COMPRESSED(spare)) {
+         datalen = tvb_captured_length_remaining(tvb, offset);
+         next_tvb = tvb_uncompress(tvb, offset,  datalen);
+         if (next_tvb) {
+             add_new_data_source(pinfo, next_tvb, "gunziped data");
+             dissect_pfcp_ies_common(next_tvb, pinfo, sub_tree, 0, message_type, args);
+         }
+     }
+     else {
          /* Dissect the IEs in the message */
          dissect_pfcp_ies_common(tvb, pinfo, sub_tree, offset, message_type, args);
+     }
  
      /* Use sequence number to track Req/Resp pairs */
      cause_aux = 16; /* Cause accepted by default. Only used when args is NULL */
*************** proto_register_pfcp(void)
*** 8167,8178 ****
              FT_UINT8, BASE_DEC, NULL, 0x7,
              NULL, HFILL }
          },
      };
  
      /* Setup protocol subtree array */
  #define NUM_INDIVIDUAL_ELEMS_PFCP    52
      gint *ett[NUM_INDIVIDUAL_ELEMS_PFCP +
!         (NUM_PFCP_IES - 1)];
  
      ett[0] = &ett_pfcp;
      ett[1] = &ett_pfcp_flags;
--- 8926,9315 ----
              FT_UINT8, BASE_DEC, NULL, 0x7,
              NULL, HFILL }
          },
+ 
+         { &hf_pfcp_cisco_config_action,
+         {
+             "Config Action", "pfcp.cisco.configaction",
+             FT_UINT8, BASE_DEC, NULL, 0,
+             NULL, HFILL }
+         },
+ 
+         { &hf_pfcp_cisco_correlation_id,
+         {
+             "Correlation ID", "pfcp.cisco.corelid",
+             FT_UINT16, BASE_HEX, NULL, 0,
+             NULL, HFILL }
+         },
+ 
+         { &hf_pfcp_cisco_sub_part_number,
+         {
+             "Number of Sub Parts", "pfcp.cisco.numsubpart",
+             FT_UINT8, BASE_DEC, NULL, 0,
+             NULL, HFILL }
+         },
+ 
+         { &hf_pfcp_cisco_sub_part_index,
+         {
+             "Sub Part Index", "pfcp.cisco.indexsubpart",
+             FT_UINT8, BASE_DEC, NULL, 0,
+             NULL, HFILL }
+         },
+ 
+         { &hf_pfcp_cisco_tlv_content,
+         {
+             "Content TLV", "pfcp.cisco.contenttlv",
+             FT_BYTES, BASE_NONE, NULL, 0,
+             NULL, HFILL }
+         },
+ 
+         { &hf_pfcp_cisco_rbase_name,
+         {
+             "RuleBase Name", "pfcp.cisco.rbasename",
+             FT_STRING, BASE_NONE, NULL, 0,
+             NULL, HFILL }
+         },
+ 
+         { &hf_pfcp_cisco_bitoctet,
+         {
+             "bitoctet", "pfcp.cisco.bitoctet",
+             FT_UINT8, BASE_HEX, NULL, 0,
+             NULL, HFILL }
+         },
+ 
+         { &hf_pfcp_cisco_msisdn_len,
+         {
+             "MSISDN Length", "pfcp.cisco.msisdnlen",
+             FT_UINT8, BASE_HEX, NULL, 0,
+             NULL, HFILL }
+         },
+ 
+         { &hf_pfcp_cisco_msisdn_val,
+         {
+             "MSISDN", "pfcp.cisco.msisdn",
+             FT_BYTES, BASE_NONE, NULL, 0,
+             NULL, HFILL }
+         },
+ 
+         { &hf_pfcp_cisco_imsi_len,
+         {
+             "IMSI Len", "pfcp.cisco.imsilen",
+             FT_UINT8, BASE_DEC, NULL, 0,
+             NULL, HFILL }
+         },
+ 
+         { &hf_pfcp_cisco_imsi_val,
+         {
+             "IMSI", "pfcp.cisco.imsi",
+             FT_BYTES, BASE_NONE, NULL, 0,
+             NULL, HFILL }
+         },
+ 
+         { &hf_pfcp_cisco_imei_len,
+         {
+             "IMEI Len", "pfcp.cisco.imeilen",
+             FT_UINT8, BASE_DEC, NULL, 0,
+             NULL, HFILL }
+         },
+ 
+         { &hf_pfcp_cisco_imei_val,
+         {
+             "IMEI", "pfcp.cisco.imsi",
+             FT_BYTES, BASE_NONE, NULL, 0,
+             NULL, HFILL }
+         },
+ 
+         { &hf_pfcp_cisco_entity_type,
+         {
+             "Entity Type", "pfcp.cisco.entitytype",
+             FT_UINT8, BASE_HEX, NULL, 0,
+             NULL, HFILL }
+         },
+ 
+         { &hf_pfcp_cisco_query_type,
+         {
+             "Query Type", "pfcp.cisco.querytype",
+             FT_UINT8, BASE_HEX, NULL, 0,
+             NULL, HFILL }
+         },
+ 
+         { &hf_pfcp_cisco_entity_name_len,
+         {
+             "Entity Name Len", "pfcp.cisco.entitynamelen",
+             FT_UINT16, BASE_DEC, NULL, 0,
+             NULL, HFILL }
+         },
+ 
+         { &hf_pfcp_cisco_entity_name_val,
+         {
+             "Entity Name", "pfcp.cisco.entityname",
+             FT_STRING, BASE_NONE, NULL, 0,
+             NULL, HFILL }
+         },
+ 
+         { &hf_pfcp_cisco_classifier_type,
+         {
+             "Classifier Type", "pfcp.cisco.classtype",
+             FT_UINT8, BASE_HEX, NULL, 0,
+             NULL, HFILL }
+         },
+ 
+         { &hf_pfcp_cisco_classifier_len,
+         {
+             "Classifier Len", "pfcp.cisco.classlen",
+             FT_UINT8, BASE_HEX, NULL, 0,
+             NULL, HFILL }
+         },
+ 
+         { &hf_pfcp_cisco_classifier_val,
+         {
+             "Classifier", "pfcp.cisco.classifier",
+             FT_BYTES, BASE_NONE, NULL, 0,
+             NULL, HFILL }
+         },
+ 
+         { &hf_pfcp_cisco_response_entity_type,
+         {
+             "Response Entity Type", "pfcp.cisco.resentitytype",
+             FT_UINT8, BASE_HEX, NULL, 0,
+             NULL, HFILL }
+         },
+ 
+         { &hf_pfcp_cisco_response_part_number,
+         {
+             "Part Number", "pfcp.cisco.partnum",
+             FT_UINT8, BASE_HEX, NULL, 0,
+             NULL, HFILL }
+         },
+ 
+         { &hf_pfcp_cisco_response_total_part_number,
+         {
+             "Total Part Number", "pfcp.cisco.totalpartnum",
+             FT_UINT8, BASE_HEX, NULL, 0,
+             NULL, HFILL }
+         },
+ 
+         { &hf_pfcp_cisco_response_data,
+         {
+             "Compressed Context Data", "pfcp.cisco.resdata",
+             FT_BYTES, BASE_NONE, NULL, 0,
+             NULL, HFILL }
+         },
+ 
+         { &hf_pfcp_cisco_response_type,
+         {
+             "Compressed Context Data", "pfcp.cisco.restype",
+             FT_UINT8, BASE_HEX, NULL, 0,
+             NULL, HFILL }
+         },
+ 
+         { &hf_pfcp_cisco_response_missing_parts,
+         {
+             "Missing Parts", "pfcp.cisco.restype",
+             FT_BYTES, BASE_NONE, NULL, 0,
+             NULL, HFILL }
+         },
+ 
+         { &hf_pfcp_cisco_packet_measurement_spare,
+         {
+             "Spare", "pfcp.cisco.measurespare",
+             FT_UINT8, BASE_HEX, NULL, 0,
+             NULL, HFILL }
+         },
+ 
+         { &hf_pfcp_cisco_packet_measurement_total,
+         {
+             "Total Packets", "pfcp.cisco.totalpkt",
+             FT_UINT64, BASE_DEC, NULL, 0,
+             NULL, HFILL }
+         },
+ 
+         { &hf_pfcp_cisco_packet_measurement_uplink,
+         {
+             "Uplink Packets", "pfcp.cisco.uplpkt",
+             FT_UINT64, BASE_DEC, NULL, 0,
+             NULL, HFILL }
+         },
+ 
+         { &hf_pfcp_cisco_packet_measurement_downlink,
+         {
+             "Downlink Packets", "pfcp.cisco.dlpkt",
+             FT_UINT64, BASE_DEC, NULL, 0,
+             NULL, HFILL }
+         },
+ 
+         { &hf_pfcp_cisco_callid,
+         {
+             "Callid", "pfcp.cisco.callid",
+             FT_UINT64, BASE_HEX, NULL, 0,
+             NULL, HFILL }
+         },
+ 
+         { &hf_pfcp_cisco_intercept_id,
+         {
+             "Intercept ID", "pfcp.cisco.interceptid",
+             FT_UINT64, BASE_HEX, NULL, 0,
+             NULL, HFILL }
+         },
+ 
+         { &hf_pfcp_cisco_charging_id,
+         {
+             "Charging ID", "pfcp.cisco.chargingid",
+             FT_UINT64, BASE_HEX, NULL, 0,
+             NULL, HFILL }
+         },
+ 
+         { &hf_pfcp_cisco_bearer_id,
+         {
+             "Bearer ID", "pfcp.cisco.bearerid",
+             FT_UINT64, BASE_HEX, NULL, 0,
+             NULL, HFILL }
+         },
+ 
+         { &hf_pfcp_cisco_context_name_len,
+         {
+             "Context Name Len", "pfcp.cisco.ctxnamelen",
+             FT_UINT8, BASE_DEC, NULL, 0,
+             NULL, HFILL }
+         },
+ 
+         { &hf_pfcp_cisco_context_name_val,
+         {
+             "Context Name", "pfcp.cisco.ctxname",
+             FT_STRING, BASE_NONE, NULL, 0,
+             NULL, HFILL }
+         },
+ 
+         { &hf_pfcp_cisco_node_capability_max_session,
+         {
+             "Capability Max Session", "pfcp.cisco.maxsess",
+             FT_UINT64, BASE_DEC, NULL, 0,
+             NULL, HFILL }
+         },
+ 
+         { &hf_pfcp_cisco_charging_chars,
+         {
+             "Charging chars", "pfcp.cisco.chargchars",
+             FT_UINT16, BASE_HEX, NULL, 0,
+             NULL, HFILL }
+         },
+ 
+         { &hf_pfcp_cisco_gtpp_group_name_len,
+         {
+             "GTPP Group Name Len", "pfcp.cisco.gtppgrouplen",
+             FT_UINT8, BASE_DEC, NULL, 0,
+             NULL, HFILL }
+         },
+ 
+         { &hf_pfcp_cisco_gtpp_group_name_val,
+         {
+             "GTPP Group Name", "pfcp.cisco.gtppgroupname",
+             FT_STRING, BASE_NONE, NULL, 0,
+             NULL, HFILL }
+         },
+ 
+         { &hf_pfcp_cisco_gtpp_context_id,
+         {
+             "GTPP Context ID", "pfcp.cisco.gtppctxid",
+             FT_UINT64, BASE_DEC, NULL, 0,
+             NULL, HFILL }
+         },
+ 
+         { &hf_pfcp_cisco_policy_name_len,
+         {
+             "Policy Name Len", "pfcp.cisco.policynamelen",
+             FT_UINT8, BASE_DEC, NULL, 0,
+             NULL, HFILL }
+         },
+ 
+         { &hf_pfcp_cisco_policy_name,
+         {
+             "Policy Name", "pfcp.cisco.policyname",
+             FT_STRING, BASE_NONE, NULL, 0,
+             NULL, HFILL }
+         },
+ 
+         { &hf_pfcp_cisco_policy_type,
+         {
+             "Policy Type", "pfcp.cisco.policytype",
+             FT_UINT64, BASE_HEX, NULL, 0,
+             NULL, HFILL }
+         },
+ 
+         { &hf_pfcp_cisco_diameter_interim_interval,
+         {
+             "Diameter Interval", "pfcp.cisco.diaminterval",
+             FT_UINT64, BASE_DEC, NULL, 0,
+             NULL, HFILL }
+         },
+ 
+         { &hf_pfcp_cisco_aaa_group_name_len,
+         {
+             "AAA Group Name Len", "pfcp.cisco.aaanamelen",
+             FT_UINT8, BASE_DEC, NULL, 0,
+             NULL, HFILL }
+         },
+ 
+         { &hf_pfcp_cisco_aaa_group_name_val,
+         {
+             "AAA Group Name", "pfcp.cisco.aaanamelen",
+             FT_STRING, BASE_NONE, NULL, 0,
+             NULL, HFILL }
+         },
+ 
+         { &hf_pfcp_cisco_aaa_group_context_id,
+         {
+             "AAA Context ID", "pfcp.cisco.aaanctxid",
+             FT_UINT64, BASE_DEC, NULL, 0,
+             NULL, HFILL }
+         },
+ 
+         { &hf_pfcp_cisco_radius_interim_interval,
+         {
+             "AAA Interval", "pfcp.cisco.aaainterval",
+             FT_UINT64, BASE_DEC, NULL, 0,
+             NULL, HFILL }
+         },
+ 
+         { &hf_pfcp_cisco_gy_offline_charging,
+         {
+             "Gy Offline Charging", "pfcp.cisco.gyoffline",
+             FT_BOOLEAN, BASE_DEC, NULL, 0,
+             NULL, HFILL }
+         },
+ 
+         { &hf_pfcp_cisco_gtpp_dictionnary,
+         {
+             "GTPP Dictionary", "pfcp.cisco.gtppdic",
+             FT_UINT8, BASE_DEC, NULL, 0,
+             NULL, HFILL }
+         },
+ 
+         { &hf_pfcp_cisco_gy_offline_charging_status,
+         {
+             "Gy Offline Status", "pfcp.cisco.gyoffstatus",
+             FT_UINT8, BASE_DEC, NULL, 0,
+             NULL, HFILL }
+         },
+ 
+         { &hf_pfcp_cisco_traffic_class,
+         {
+             "Traffic Class", "pfcp.cisco.trafclass",
+             FT_UINT16, BASE_HEX, NULL, 0,
+             NULL, HFILL }
+         },
+ 
+         { &hf_pfcp_cisco_copy_inner_outer_flag,
+         {
+             "Copy Inner/Outter flag", "pfcp.cisco.inoutflag",
+             FT_UINT16, BASE_HEX, NULL, 0,
+             NULL, HFILL }
+         },
      };
  
      /* Setup protocol subtree array */
  #define NUM_INDIVIDUAL_ELEMS_PFCP    52
      gint *ett[NUM_INDIVIDUAL_ELEMS_PFCP +
!         (NUM_PFCP_IES - 1) + (NUM_PFCP_CISCO_IES - 1)];
  
      ett[0] = &ett_pfcp;
      ett[1] = &ett_pfcp_flags;
*************** proto_register_pfcp(void)
*** 8247,8252 ****
--- 9384,9396 ----
          ett_pfcp_elem[i] = -1;
          ett[last_index] = &ett_pfcp_elem[i];
      }
+ 
+     for (i = 0; i < (NUM_PFCP_CISCO_IES-1); i++, last_index++)
+     {
+         ett_pfcfp_cisco_elem[i] = -1;
+         ett[last_index] = &ett_pfcfp_cisco_elem[i];
+     }
+ 
      proto_pfcp = proto_register_protocol("Packet Forwarding Control Protocol", "PFCP", "pfcp");
      pfcp_handle = register_dissector("pfcp", dissect_pfcp, proto_pfcp);
      module_pfcp = prefs_register_protocol(proto_pfcp, proto_reg_handoff_pfcp);
